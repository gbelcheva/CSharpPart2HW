Structural Design Patterns
===================


[GitHub Link](https://github.com/gbelcheva/TelerikAcademy/blob/master/HighQualityCode/HW15-Structural-Patterns)


Decorator
-------------
----------
Дизайн моделът Decorator дава възможност за добавяне на допълнително поведение и отговорности динамично, при изпълнението на кода, вместо дефиниране на допълнителните функционалности предварително и статично.

Имплементацията се състои от интерфейс Interface, който е реализиран от главния клас CoreFunctionality, декориращия абстрактен клас OptionalWrapper и наследниците на OptionalWrapper -- OptionalOne, OptionalTwo, OptionalThree... CoreFunctionality е класът, чиято функционалност ще бъде разширена. OptionalWrapper е абстрактен клас, който имплементира Interface и съдържа референция към инстанция на класа CoreFunctionality -- играе ролята на основен клас с обща функционалност за всички декоратори. 

![Decorator Design Pattern](https://sourcemaking.com/files/v2/content/patterns/Decorator__1-2x.png)

Моделът се използва за добавяне на допълнителни функционалности динамично и без да се нарушава принципа Open-Closed -- основният клас остава затворен за модификация, но отворен за добавяне на нови функционалности.

Проблем при Decorator модела е, че типовете на декораторите и декорирания клас не съвпадат. От това следва, че след декорацията типът на основния клас вече е типа на декориращия клас, което може да доведе до проблеми при проверки на типа. Друг проблем на модела е, че увеличава сложността на създаване на обекти -- след създаването на основния клас се налага декориране с всеки декоратор поотделно.

----------


Adapter
-------------
----------


Adapter моделът дава възможност за приспособяване на даден интерфейс към такъв, който клиентът очаква.

Състои се от клас Adaptee, който има дадена функционалност, клас Client, който използва Target интерфейс, а трябва да използва функционалността на Adaptee, и клас Adapter, който приспособява интерфейсът на Adaptee към Target.

![Adapter Design Pattern](http://www.bogotobogo.com/DesignPatterns/images/adapter/class_adapter.gif)

Дизайн моделът се използва, когато вече съществува код с желана функционалност, но интерфейсът му е несъвместим с новия код. Например отдавна писан и остарял код, който може да бъде използван в по-нови приложения. Adapter моделът се грижи за спазване на Open-Closed принципът -- старият и новият код остават непроменени, а добавянето на нов код позволява съвместната им работа.

Проблеми на моделът са увеличаването на повторение на код, както и усложняване на кода, когато са нужни повече адаптори за достигане до желания интерфейс.

----------
Facade
-------------
----------


Facade моделът скрива сложна функционалност на система от класове, като предоставя един единствен прост интерфейс за работа с основните части на системата.

Състои се от клас Client, който използва система от класове Subsystem със сложни зависимости помежду им, и клас Facade, който опростява достъпа до Subsystem, като осигурява на Client прост интерфейс, който да използва. 

![Facade Design Pattern](http://www.sable.mcgill.ca/~hendren/303/BookSlides/Ch7/images/Ch7_un01.jpg)

Facade моделът намалява къплинга между Client и Subsystem, което позволява преправянето на класовете в Subsystem, без това да засегне Client. Също така, ограничава зависимостите при компилация в големи и сложни системи, увеличава сигурността на приложението, а в същото време е лесен за имплементация.

Този модел не притежава сериозни недостатъци, тъй като не добавя никакви нови функционалности, а единствено опростява вече съществуващи интерфейси.

----------