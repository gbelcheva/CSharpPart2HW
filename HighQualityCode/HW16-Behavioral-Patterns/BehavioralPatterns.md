Behavioral Design Patterns
===================

![GitHub Link](https://github.com/gbelcheva/TelerikAcademy/blob/master/HighQualityCode/HW16-Behavioral-Patterns)


Chain Of Responsibility
-------------
----------
Дизайн моделът Chain of Responsibility се грижи за обработката на заявки, като същевременно намалява къплинга между изпращача на заявката и класът, който я обработва, посредством верига от обработващи класове, разделени по типа на заявките, които обработват. 

Имплементацията се състои от интерфейс Handler, който се имплементира от конкретни обработващи класове ConcreteHandler1, ConcreteHandler2... ConcreteHandler класовете са свързани помежду си във верига (всеки ConcreteHandler съдържа референция към друг ConcreteHandler) и всеки обработва специфични заявки. Когато даден ConcreteHandler не може да обработи заявката, която е получил, тя се препраща по веригата, докато не стигне до подходящ клас, който да я обработи. Класът Client изпраща заявки до първия клас от веригата от обработващи класове.

![Chain of Responsibility Design Pattern](http://www.dofactory.com/images/diagrams/net/chain.gif)

Моделът се използва, когато няколко класа обработват завки и не е ясно предварително кой клас трябва да обработи получената заявка. Също така, когато заявката няма точен получател. Пример е обработката на изключения.

Един от рисковете на Chain of Responsibility модела е, че ако някой от получателите не извика следващия получател, заявката се губи по веригата. Това е следствие от факта, че класът, който приема заявката от клиента, може да не е класът, който я обработва. Освен това, някои заявки може въобще да не стигнат до подходящ клас, който да ги обработи, но въпреки всичко ще минат през цялата верига, което натоварва приложението ненужно.

----------


Specification
-------------
----------
Дизайн моделът Specification разделя сложна бизнес логика на прости правила, които даден обект може да задоволява или не. Правилата могат да се комбинират, за да съставят по-сложно правило, а същевременно синтаксисът е четим и разбираем.

Състои се от интерфейс ISpecification, който се имплементира от абстрактния клас CompositeSpecification. Този клас се наследява от всеки конкретен Specification клас. CompositeSpecification съдържа общите класове And(), Or(), Not(), и абстрактния клас IsSatisfiedBy(), чиято имплементация е оставена на наследниците. Всяко извикване на IsSatisfiedBy() връща обект от тип ISpecification, което позволява верижно извикване и комбиниране на правилата.

![Specification Design Pattern](https://upload.wikimedia.org/wikipedia/commons/8/8b/Specification_UML_v2.png)

Specification моделът обуславя слаб къплинг между бизнес правилата и обектите, които биват тествани. Полезен е за гъвкаво конструиране на съставни правила без използване на сложни и неразбираеми if-else конструкции. Значително подобрява и улеснява четимостта, поддръжката, употребата и преизползването на кода, като при това принципът за единствена отговорност (Single Responsibility Principle) остава спазен. Пример са LINQ заявките, които могат да бъдат извиквани една след друга във верига, съставяйки сложни заявки с лекота и без писане на дълъг и неразбираем код.

Единственият недостатък на модела, може би, е, че дебъгването на сложни съставни изрази става невъзможно.

----------
Observer
-------------
----------
Observer моделът определя взаимеодействието между един субект и много други обекти наблюдатели, които следят състоянието на субекта. При промяна на състоянието на обекта, всички наблюдатели биват известени.

Състои се от Subject интерфейс, който се имплементира от ConcreteSubject обекти, и Observer интерфейс, имплементиран от конкретни наблюдатели ConcreteObserver. Subject пази референции към ConcreteObserver класове и има функционалност за добавяне и премахване на наблюдатели. От своя страна всеки наблюдател ConcreteObserver пази референция за субекта, който следи, и неговото състояние .

![Observer Design Pattern](http://www.dofactory.com/images/diagrams/net/observer.gif)

Предимство на модела е, че предотвратява силния къплинг между наблюдателите и субектите -- наблюдателите се определят само повреме на работа на приложението, а конкретните детайли от имплементацията на наблюдателите и тяхната употреба остават неизвестни за субектите. Освен това, известието, което изпраща субекта, може да няма точен получател. По този начин всеки наблюдател, който се интересува от състоянието на субекта може да получи известие от него.

От друга страна, дебъгването при голям брой наблюдатели става трудно. Зле дефинирани критерии за промяна на състоянието на субекта пък водят до лъжливи известия. Друго объркване може да настъпи, ако даден наблюдател наблюдава повече от един субект, тогава субектите трябва да изпращат референция към себе си при промяна на състоянието. Проблем може да има и ако субектът променя състоянието си твърде често. В този случай може да е по-разумно наблюдателят сам да решава кога да обнови състоянието на субекта. Трябва да се следи и дали известието, което субектът изпраща, съдържа актуалното състояние и дали състоянието не се променя след изпращане на известието. В този случай наблюдателят би получил остаряло състояние на субекта.

----------
